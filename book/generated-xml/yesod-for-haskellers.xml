<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<section id="yesod-for-haskellers_yesod_for_haskellers">
<title>Yesod for Haskellers</title>
<simpara>The majority of this book is built around giving practical information on how
to get common tasks done, without drilling too much into the details of what&#8217;s
going on under the surface. While the book presumes knowledge of Haskell, it
does not follow the typical style of many Haskell libraries introductions. Many
seasoned Haskellers are put off by this hiding of implementation details. The
purpose of this chapter is to address those concerns.</simpara>
<simpara>In this chapter, we&#8217;ll start off from a bare minimum web application, and
build up to more complicated examples, explaining the components and their
types along the way.</simpara>
<section id="yesod-for-haskellers_hello_warp">
<title>Hello Warp</title>
<simpara>Let&#8217;s start off with the most bare minimum application we can think of:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseLBS)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = sendResponse $ responseLBS
    status200
    [("Content-Type", "text/plain")]
    "Hello Warp!"</programlisting>
<simpara>Wait a minute, there&#8217;s no Yesod in there! Don&#8217;t worry, we&#8217;ll get there.
Remember, we&#8217;re building from the ground up, and in Yesod, the ground floor is
WAI, the Web Application Interface. WAI sits between a web <emphasis role="strong">handler</emphasis>, such as a
web server or a test framework, and a web <emphasis role="strong">application</emphasis>. In our case, the
handler is Warp, a high performance web server, and our application is the
<literal>app</literal> function.</simpara>
<simpara>What&#8217;s this mysterious <literal>Application</literal> type? It&#8217;s a type synonym defined as:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">type Application = Request
                -&gt; (Response -&gt; IO ResponseReceived)
                -&gt; IO ResponseReceived</programlisting>
<simpara>The <literal>Request</literal> value contains information such as the requested path, query
string, request headers, request body, and the IP address of the client. The
second argument is the &#8220;send response&#8221; function. Instead of simply having the
application return an <literal>IO Response</literal>, WAI uses continuation passing style to
allow for full exception safety, similar to how the <literal>bracket</literal> function works.</simpara>
<simpara>We can use this to do some simple dispatching:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, pathInfo, responseLBS)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app req sendResponse =
    case pathInfo req of
        ["foo", "bar"] -&gt; sendResponse $ responseLBS
            status200
            [("Content-Type", "text/plain")]
            "You requested /foo/bar"
        _ -&gt; sendResponse $ responseLBS
            status200
            [("Content-Type", "text/plain")]
            "You requested something else"</programlisting>
<simpara>WAI mandates that the path be split into individual fragments (the stuff
between forward slashes) and converted into text. This allows for easy pattern
matching. If you need the original, unmodified <literal>ByteString</literal>, you can use
<literal>rawPathInfo</literal>. For more information on the available fields, please see the WAI
Haddocks.</simpara>
<simpara>That addresses the request side; what about responses? We&#8217;ve already seen
<literal>responseLBS</literal>, which is a convenient way of creating a response from a lazy
<literal>ByteString</literal>. That function takes three arguments: the status code, a list of
response headers (as key/value pairs), and the body itself. But <literal>responseLBS</literal>
is just a convenience wrapper. Under the surface, WAI uses blaze-builder&#8217;s
<literal>Builder</literal> data type to represent the raw bytes. Let&#8217;s dig down another level
and use that directly:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder (Builder, fromByteString)
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseBuilder)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = sendResponse $ responseBuilder
    status200
    [("Content-Type", "text/plain")]
    (fromByteString "Hello from blaze-builder!" :: Builder)</programlisting>
<simpara>This opens up some nice opportunities for efficiently building up response
bodies, since <literal>Builder</literal> allows for O(1) append operations. We&#8217;re also able to
take advantage of blaze-html, which sits on top of blaze-builder. Let&#8217;s see our
first HTML application.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types            (status200)
import           Network.Wai                   (Application, responseBuilder)
import           Network.Wai.Handler.Warp      (run)
import           Text.Blaze.Html.Renderer.Utf8 (renderHtmlBuilder)
import           Text.Blaze.Html5              (Html, docTypeHtml)
import qualified Text.Blaze.Html5              as H

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = sendResponse $ responseBuilder
    status200
    [("Content-Type", "text/html")] -- yay!
    (renderHtmlBuilder myPage)

myPage :: Html
myPage = docTypeHtml $ do
    H.head $ do
        H.title "Hello from blaze-html and Warp"
    H.body $ do
        H.h1 "Hello from blaze-html and Warp"</programlisting>
<simpara>But there&#8217;s a limitation with using a pure <literal>Builder</literal> value: we need to create
the entire response body before returning the <literal>Response</literal> value. With lazy
evaluation, that&#8217;s not as bad as it sounds, since not all of the body will live in
memory at once. However, if we need to perform some I/O to generate our
response body (such as reading data from a database), we&#8217;ll be in trouble.</simpara>
<simpara>To deal with that situation, WAI provides a means for generating streaming
response bodies. It also allows explicit control of flushing the stream.  Let&#8217;s
see how this works.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder           (Builder, fromByteString)
import           Blaze.ByteString.Builder.Char.Utf8 (fromShow)
import           Control.Concurrent                 (threadDelay)
import           Control.Monad                      (forM_)
import           Control.Monad.Trans.Class          (lift)
import           Data.Monoid                        ((&lt;&gt;))
import           Network.HTTP.Types                 (status200)
import           Network.Wai                        (Application,
                                                     responseStream)
import           Network.Wai.Handler.Warp           (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = sendResponse $ responseStream
    status200
    [("Content-Type", "text/plain")]
    myStream

myStream :: (Builder -&gt; IO ()) -&gt; IO () -&gt; IO ()
myStream send flush = do
    send $ fromByteString "Starting streaming response.\n"
    send $ fromByteString "Performing some I/O.\n"
    flush
    -- pretend we're performing some I/O
    threadDelay 1000000
    send $ fromByteString "I/O performed, here are some results.\n"
    forM_ [1..50 :: Int] $ \i -&gt; do
        send $ fromByteString "Got the value: " &lt;&gt;
               fromShow i &lt;&gt;
               fromByteString "\n"</programlisting>
<note><simpara>wai previously relied on the conduit library for its streaming data
abstraction, but has since gotten rid of that dependency. However, conduit is
still well supported in the WAI ecosystem, via the wai-conduit helper package.</simpara></note>
<simpara>Another common requirement when dealing with a streaming response is safely
allocating a scarce resource- such as a file handle. By <emphasis role="strong">safely</emphasis>, I mean
ensuring that the resource will be released, even in the case of some
exception. This is where the continuation passing style mentioned above comes
into play:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder (fromByteString)
import qualified Data.ByteString          as S
import           Data.Conduit             (Flush (Chunk), ($=))
import           Data.Conduit.Binary      (sourceHandle)
import qualified Data.Conduit.List        as CL
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseStream)
import           Network.Wai.Handler.Warp (run)
import           System.IO                (IOMode (ReadMode), withFile)

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = withFile "index.html" ReadMode $ \handle -&gt;
    sendResponse $ responseStream
        status200
        [("Content-Type", "text/html")]
        $ \send _flush -&gt;
            let loop = do
                    bs &lt;- S.hGet handle 4096
                    if S.null bs
                        then return ()
                        else send (fromByteString bs) &gt;&gt; loop
             in loop</programlisting>
<simpara>Notice how we&#8217;re able to take advantage of existing exception safe functions
like <literal>withFile</literal> to deal with exceptions properly.</simpara>
<simpara>But in the case of serving files, it&#8217;s more efficient to use <literal>responseFile</literal>,
which can use the <literal>sendfile</literal> system call to avoid unnecessary buffer copies:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseFile)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req sendResponse = sendResponse $ responseFile
    status200
    [("Content-Type", "text/html")]
    "index.html"
    Nothing -- means "serve whole file"
            -- you can also serve specific ranges in the file</programlisting>
<simpara>There are many aspects of WAI we haven&#8217;t covered here. One important topic is WAI middlewares. We also haven&#8217;t inspected request bodies at all. But for the purposes of understanding Yesod, we&#8217;ve covered enough for the moment.</simpara>
</section>
<section id="yesod-for-haskellers_what_about_yesod">
<title>What about Yesod?</title>
<simpara>In all our excitement about WAI and Warp, we still haven&#8217;t seen anything about Yesod! Since we just learnt all about WAI, our first question should be: how does Yesod interact with WAI. The answer to that is one very important function:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">toWaiApp :: YesodDispatch site =&gt; site -&gt; IO Application</programlisting>
<note><simpara>There&#8217;s an even more basic function in Yesod, called <literal>toWaiAppPlain</literal>. The
distinction is that <literal>toWaiAppPlain</literal> doesn&#8217;t install any additional WAI
middlewares, while <literal>toWaiApp</literal> provides commonly used middlewares, such as
logging, GZIP compression, and HEAD request method handling.</simpara></note>
<simpara>This function takes some site value, which must be an instance of
<literal>YesodDispatch</literal>, and creates an <literal>Application</literal>. This function lives in the <literal>IO</literal>
monad, since it will likely perform actions like allocating a shared logging
buffer. The more interesting question is what this <literal>site</literal> value is all about.</simpara>
<simpara>Yesod has a concept of a <emphasis role="strong">foundation data type</emphasis>. This is a data type at the
core of each application, and is used in three important ways:</simpara>
<itemizedlist>
<listitem>
<simpara>
It can hold onto values that are initialized and shared amongst all aspects of your application, such as an HTTP connection manager, a database connection pool, settings loaded from a file, or some shared mutable state like a counter or cache.
</simpara>
</listitem>
<listitem>
<simpara>
Typeclass instances provide even more information about your application. The <literal>Yesod</literal> typeclass has various settings, such as what the default template of your app should be, or the maximum allowed request body size. The <literal>YesodDispatch</literal> class indicates how incoming requests should be dispatched to handler functions. And there are a number of typeclasses commonly used in Yesod helper libraries, such as <literal>RenderMessage</literal> for i18n support or <literal>YesodJquery</literal> for providing the shared location of the jQuery Javascript library.
</simpara>
</listitem>
<listitem>
<simpara>
Associated types (i.e., type families) are used to create a related <emphasis role="strong">route data type</emphasis> for each application. This is a simple ADT that represents all legal routes in your application. But using this intermediate data type instead of dealing directly with strings, Yesod applications can take advantage of the compiler to prevent creating invalid links. This feature is known as <emphasis role="strong">type safe URLs</emphasis>.
</simpara>
</listitem>
</itemizedlist>
<simpara>In keeping with the spirit of this chapter, we&#8217;re going to create our first
Yesod application the hard way, by writing everything manually. We&#8217;ll
progressively add more convenience helpers on top as we go along.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Network.HTTP.Types            (status200)
import           Network.Wai                   (responseBuilder)
import           Network.Wai.Handler.Warp      (run)
import           Text.Blaze.Html.Renderer.Utf8 (renderHtmlBuilder)
import qualified Text.Blaze.Html5              as H
import           Yesod.Core                    (Html, RenderRoute (..), Yesod,
                                                YesodDispatch (..), toWaiApp)
import           Yesod.Core.Types              (YesodRunnerEnv (..))

-- | Our foundation datatype.
data App = App
    { welcomeMessage :: !Html
    }

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

instance YesodDispatch App where
    yesodDispatch (YesodRunnerEnv _logger site _sessionBackend _ _) _req sendResponse =
        sendResponse $ responseBuilder
            status200
            [("Content-Type", "text/html")]
            (renderHtmlBuilder $ welcomeMessage site)

main :: IO ()
main = do
    -- We could get this message from a file instead if we wanted.
    let welcome = H.p "Welcome to Yesod!"
    waiApp &lt;- toWaiApp App
        { welcomeMessage = welcome
        }
    run 3000 waiApp</programlisting>
<simpara>OK, we&#8217;ve added quite a few new pieces here, let&#8217;s attack them one at a time.
The first thing we&#8217;ve done is created a new datatype, <literal>App</literal>. This is commonly
used as the foundation data type name for each application, though you&#8217;re free
to use whatever name you want. We&#8217;ve added one field to this datatype,
<literal>welcomeMessage</literal>, which will hold the content for our homepage.</simpara>
<simpara>Next we declare our <literal>Yesod</literal> instance. We just use the default values for all of
the methods for this example. More interesting is the <literal>RenderRoute</literal> typeclass.
This is the heart of type-safe URLs. We create an associated data type for
<literal>App</literal> which lists all of our app&#8217;s accepted routes. In this case, we have just
one: the homepage, which we call <literal>HomeR</literal>. It&#8217;s yet another Yesod naming
convention to append <literal>R</literal> to all of the route data constructors.</simpara>
<simpara>We also need to create a <literal>renderRoute</literal> method, which converts each type-safe
route value into a tuple of path pieces and query string parameters. We&#8217;ll get
to more interesting examples later, but for now, our homepage has an empty list
for both of those.</simpara>
<simpara><literal>YesodDispatch</literal> determines how our application behaves. It has one method,
<literal>yesodDispatch</literal>, of type:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">yesodDispatch :: YesodRunnerEnv site -&gt; Application</programlisting>
<simpara><literal>YesodRunnerEnv</literal> provides three values: a <literal>Logger</literal> value for outputting log
messages, the foundation datatype value itself, and a session backend, used for
storing and retrieving information for the user&#8217;s active session. In real Yesod
applications, as you&#8217;ll see shortly, you don&#8217;t need to interact with these
values directly, but it&#8217;s informative to understand what&#8217;s under the surface.</simpara>
<simpara>The return type of <literal>yesodDispatch</literal> is <literal>Application</literal> from WAI. But as we saw
earlier, <literal>Application</literal> is simply a CPSed function from <literal>Request</literal> to <literal>Response</literal>. So
our implementation of <literal>yesodDispatch</literal> is able to use everything we learned
about WAI above. Notice also how we accessed the <literal>welcomeMessage</literal> from our
foundation data type.</simpara>
<simpara>Finally, we have the <literal>main</literal> function. The <literal>App</literal> value is easy to create and, as
you can see, you could just as easily have performed some I/O to acquire the
welcome message. We use <literal>toWaiApp</literal> to obtain a WAI application, and then pass
off our application to Warp, just like we did in the past.</simpara>
<simpara>Congratulations, you&#8217;ve now seen your first Yesod application! (Or, at least
your first Yesod application in this chapter.)</simpara>
</section>
<section id="yesod-for-haskellers_the_handlert_monad_transformer">
<title>The HandlerT monad transformer</title>
<simpara>While that example was technically using Yesod, it was incredibly uninspiring.
There&#8217;s no question that Yesod did nothing more than get in our way relative to
WAI. And that&#8217;s because we haven&#8217;t started taking advantage of any of Yesod&#8217;s
features. Let&#8217;s address that, starting with the <literal>HandlerT</literal> monad transformer.</simpara>
<simpara>There are many common things you&#8217;d want to do when handling a single request,
e.g.:</simpara>
<itemizedlist>
<listitem>
<simpara>
Return some HTML.
</simpara>
</listitem>
<listitem>
<simpara>
Redirect to a different URL.
</simpara>
</listitem>
<listitem>
<simpara>
Return a 404 not found response.
</simpara>
</listitem>
<listitem>
<simpara>
Do some logging.
</simpara>
</listitem>
</itemizedlist>
<simpara>To encapsulate all of this common functionality, Yesod provides a <literal>HandlerT</literal>
monad transformer. The vast majority of the code you write in Yesod will live
in this transformer, so you should get acquainted with it. Let&#8217;s start off by
replacing our previous <literal>YesodDispatch</literal> instance with a new one that takes
advantage of <literal>HandlerT</literal>:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Network.Wai              (pathInfo)
import           Network.Wai.Handler.Warp (run)
import qualified Text.Blaze.Html5         as H
import           Yesod.Core               (HandlerT, Html, RenderRoute (..),
                                           Yesod, YesodDispatch (..), getYesod,
                                           notFound, toWaiApp, yesodRunner)

-- | Our foundation datatype.
data App = App
    { welcomeMessage :: !Html
    }

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

getHomeR :: HandlerT App IO Html
getHomeR = do
    site &lt;- getYesod
    return $ welcomeMessage site

instance YesodDispatch App where
    yesodDispatch yesodRunnerEnv req sendResponse =
        let maybeRoute =
                case pathInfo req of
                    [] -&gt; Just HomeR
                    _  -&gt; Nothing
            handler =
                case maybeRoute of
                    Nothing -&gt; notFound
                    Just HomeR -&gt; getHomeR
         in yesodRunner handler yesodRunnerEnv maybeRoute req sendResponse

main :: IO ()
main = do
    -- We could get this message from a file instead if we wanted.
    let welcome = H.p "Welcome to Yesod!"
    waiApp &lt;- toWaiApp App
        { welcomeMessage = welcome
        }
    run 3000 waiApp</programlisting>
<simpara><literal>getHomeR</literal> is our first handler function. (That name is yet another naming
convention in the Yesod world: the lower case HTTP request method, followed by
the route constructor name.) Notice its signature: <literal>HandlerT App IO Html</literal>. It&#8217;s
so common to have the monad stack <literal>HandlerT App IO</literal> that most applications have
a type synonym for it, <literal>type Handler = HandlerT App IO</literal>. The function is
returning some <literal>Html</literal>. You might be wondering if Yesod is hard-coded to only
work with <literal>Html</literal> values. We&#8217;ll explain that detail in a moment.</simpara>
<simpara>Our function body is short. We use the <literal>getYesod</literal> function to get the
foundation data type value, and then return the <literal>welcomeMessage</literal> field. We&#8217;ll
build up more interesting handlers as we continue.</simpara>
<simpara>The implementation of <literal>yesodDispatch</literal> is now quite different. The key to it is
the <literal>yesodRunner</literal> function, which is a low-level function for converting
<literal>HandlerT</literal> stacks into WAI <literal>Application</literal>s. Let&#8217;s look at its type signature:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">yesodRunner :: (ToTypedContent res, Yesod site)
            =&gt; HandlerT site IO res
            -&gt; YesodRunnerEnv site
            -&gt; Maybe (Route site)
            -&gt; Application</programlisting>
<simpara>We&#8217;re already familiar with <literal>YesodRunnerEnv</literal> from our previous example. As you
can see in our call to <literal>yesodRunner</literal> above, we pass that value in unchanged.
The <literal>Maybe (Route site)</literal> is a bit interesting, and gives us more insight into
how type-safe URLs work. Until now, we only saw the rendering side of these
URLs. But just as important is the <emphasis role="strong">parsing</emphasis> side: converting a requested path
into a route value. In our example, this code is just a few lines, and we store
the result in <literal>maybeRoute</literal>.</simpara>
<note><simpara>It&#8217;s true that our current parse function is small, but in a larger
application it would need to be more complex, also dealing with issues like
dynamic parameters. At that point, it becomes a non-trivial endeavor to ensure
that our parsing and rendering functions remain in proper alignment.  We&#8217;ll
discuss how Yesod deals with that later.</simpara></note>
<simpara>Coming back to the parameters to <literal>yesodRunner</literal>: we&#8217;ve now addressed the <literal>Maybe
(Route site)</literal> and <literal>YesodRunerEnv site</literal>. To get our <literal>HandlerT site IO res</literal>
value, we pattern match on <literal>maybeRoute</literal>. If it&#8217;s <literal>Just HomeR</literal>, we use
<literal>getHomeR</literal>. Otherwise, we use the <literal>notFound</literal> function, which is a built-in
function that returns a 404 not found response, using your default site
template. That template can be overridden in the Yesod typeclass; out of the
box, it&#8217;s just a boring HTML page.</simpara>
<simpara>This almost all makes sense, except for one issue: what&#8217;s that <literal>ToTypedContent</literal>
typeclass, and what does it have to do with our <literal>Html</literal> response? Let&#8217;s start by
answering my question from above: no, Yesod does <emphasis role="strong">not</emphasis> in any way hard code
support for <literal>Html</literal>. A handler function can return any value that has an
instance of <literal>ToTypedContent</literal>. This typeclass (which we will examine in a moment)
provides both a mime-type and a representation of the data that WAI can
consume. <literal>yesodRunner</literal> then converts that into a WAI response, setting the
<literal>Content-Type</literal> response header to the mime type, using a 200 OK status code,
and sending the response body.</simpara>
<section id="yesod-for-haskellers_to_content_to_typedcontent">
<title>(To)Content, (To)TypedContent</title>
<simpara>At the very core of Yesod&#8217;s content system are the following types:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">data Content = ContentBuilder !Builder !(Maybe Int) -- ^ The content and optional content length.
             | ContentSource !(Source (ResourceT IO) (Flush Builder))
             | ContentFile !FilePath !(Maybe FilePart)
             | ContentDontEvaluate !Content

type ContentType = ByteString
data TypedContent = TypedContent !ContentType !Content</programlisting>
<simpara><literal>Content</literal> should remind you a bit of the WAI response types. <literal>ContentBuilder</literal>
is similar to <literal>responseBuilder</literal>, <literal>ContentSource</literal> is like <literal>responseStream</literal> but specialized to conduit, and
<literal>ContentFile</literal> is like <literal>responseFile</literal>. Unlike their WAI counterparts, none of
these constructors contain information on the status code or response headers;
that&#8217;s handled orthogonally in Yesod.</simpara>
<simpara>The one completely new constructor is <literal>ContentDontEvaluate</literal>. By default, when
you create a response body in Yesod, Yesod fully evaluates the body before
generating the response. The reason for this is to ensure that there are no
impure exceptions in your value. Yesod wants to make sure to catch any such
exceptions before starting to send your response so that, if there <emphasis role="strong">is</emphasis> an
exception, Yesod can generate a proper 500 internal server error response
instead of simply dying in the middle of sending a non-error response. However,
performing this evaluation can cause more memory usage. Therefore, Yesod
provides a means of opting out of this protection.</simpara>
<simpara><literal>TypedContent</literal> is then a minor addition to <literal>Content</literal>: it includes the
<literal>ContentType</literal> as well. Together with a convention that an application returns a
200 OK status unless otherwise specified, we have everything we need from the
<literal>TypedContent</literal> type to create a response.</simpara>
<simpara>Yesod <emphasis role="strong">could</emphasis> have taken the approach of requiring users to always return
<literal>TypedContent</literal> from a handler function, but that would have required manually
converting to that type. Instead, Yesod uses a pair of typeclasses for this,
appropriately named <literal>ToContent</literal> and <literal>ToTypedContent</literal>. They have exactly the
definitions you&#8217;d expect:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">class ToContent a where
    toContent :: a -&gt; Content
class ToContent a =&gt; ToTypedContent a where
    toTypedContent :: a -&gt; TypedContent</programlisting>
<simpara>And Yesod provides instances for many common data types, including <literal>Text</literal>,
<literal>Html</literal>, and aeson&#8217;s <literal>Value</literal> type (containing JSON data). That&#8217;s how the
<literal>getHomeR</literal> function was able to return <literal>Html</literal>: Yesod knows how to convert it to
<literal>TypedContent</literal>, and from there it can be converted into a <literal>WAI</literal> response.</simpara>
</section>
<section id="yesod-for-haskellers_hascontenttype_and_representations">
<title>HasContentType and representations</title>
<simpara>This typeclass approach allows for one other nice abstraction. For many types, the type system itself lets us know what the content-type for the content should be. For example, <literal>Html</literal> will always be served with a <literal>text/html</literal> content-type.</simpara>
<note><simpara>This isn&#8217;t true for all instance of <literal>ToTypedContent</literal>. For a counter
example, consider the <literal>ToTypedContent TypedContent</literal> instance.</simpara></note>
<simpara>Some requests to a web application can be displayed with various <emphasis role="strong">representation</emphasis>. For example, a request for tabular data could be served with:</simpara>
<itemizedlist>
<listitem>
<simpara>
An HTML table
</simpara>
</listitem>
<listitem>
<simpara>
A CSV file
</simpara>
</listitem>
<listitem>
<simpara>
XML
</simpara>
</listitem>
<listitem>
<simpara>
JSON data to be consumed by some client-side Javascript
</simpara>
</listitem>
</itemizedlist>
<simpara>The HTTP spec allows a client to specify its preference of representation via
the <literal>accept</literal> request header. And Yesod allows a handler function to use the
<literal>selectRep</literal>/<literal>provideRep</literal> function combo to provide multiple representations,
and have the framework automatically choose the appropriate one based on the
client headers.</simpara>
<simpara>The last missing piece to make this all work is the <literal>HasContentType</literal> typeclass:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">class ToTypedContent a =&gt; HasContentType a where
    getContentType :: Monad m =&gt; m a -&gt; ContentType</programlisting>
<simpara>The parameter <literal>m a</literal> is just a poor man&#8217;s <literal>Proxy</literal> type. And, in hindsight, we
should have used <literal>Proxy</literal>, but that would now be a breaking change. There are
instances for this typeclass for most data types supported by <literal>ToTypedContent</literal>.
Below is our example from above, tweaked just a bit to provide multiple
representations of the data:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Data.Text                (Text)
import           Network.Wai              (pathInfo)
import           Network.Wai.Handler.Warp (run)
import qualified Text.Blaze.Html5         as H
import           Yesod.Core               (HandlerT, Html, RenderRoute (..),
                                           TypedContent, Value, Yesod,
                                           YesodDispatch (..), getYesod,
                                           notFound, object, provideRep,
                                           selectRep, toWaiApp, yesodRunner,
                                           (.=))

-- | Our foundation datatype.
data App = App
    { welcomeMessageHtml :: !Html
    , welcomeMessageText :: !Text
    , welcomeMessageJson :: !Value
    }

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

getHomeR :: HandlerT App IO TypedContent
getHomeR = do
    site &lt;- getYesod
    selectRep $ do
        provideRep $ return $ welcomeMessageHtml site
        provideRep $ return $ welcomeMessageText site
        provideRep $ return $ welcomeMessageJson site

instance YesodDispatch App where
    yesodDispatch yesodRunnerEnv req sendResponse =
        let maybeRoute =
                case pathInfo req of
                    [] -&gt; Just HomeR
                    _  -&gt; Nothing
            handler =
                case maybeRoute of
                    Nothing -&gt; notFound
                    Just HomeR -&gt; getHomeR
         in yesodRunner handler yesodRunnerEnv maybeRoute req sendResponse

main :: IO ()
main = do
    waiApp &lt;- toWaiApp App
        { welcomeMessageHtml = H.p "Welcome to Yesod!"
        , welcomeMessageText = "Welcome to Yesod!"
        , welcomeMessageJson = object ["msg" .= ("Welcome to Yesod!" :: Text)]
        }
    run 3000 waiApp</programlisting>
</section>
<section id="yesod-for-haskellers_convenience_literal_warp_literal_function">
<title>Convenience <literal>warp</literal> function</title>
<simpara>And one minor convenience you&#8217;ll see quite a bit in the Yesod world. It&#8217;s very
common to call <literal>toWaiApp</literal> to create a WAI <literal>Application</literal>, and then pass that to
Warp&#8217;s <literal>run</literal> function. So Yesod provides a convenience <literal>warp</literal> wrapper function.
We can replace our previous <literal>main</literal> function with the following:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">main :: IO ()
main =
    warp 3000 App
        { welcomeMessageHtml = H.p "Welcome to Yesod!"
        , welcomeMessageText = "Welcome to Yesod!"
        , welcomeMessageJson = object ["msg" .= ("Welcome to Yesod!" :: Text)]
        }</programlisting>
<simpara>There&#8217;s also a <literal>warpEnv</literal> function which reads the port number from the <literal>PORT</literal>
environment variable, which is useful for working with platforms such as FP
Haskell Center, or deployment tools like Keter.</simpara>
</section>
</section>
<section id="yesod-for-haskellers_writing_handlers">
<title>Writing handlers</title>
<simpara>Since the vast majority of your application will end up living in the
<literal>HandlerT</literal> monad transformer, it&#8217;s not surprising that there are quite a few
functions that work in that context. <literal>HandlerT</literal> is an instance of many common
typeclasses, including <literal>MonadIO</literal>, <literal>MonadTrans</literal>, <literal>MonadBaseControl</literal>,
<literal>MonadLogger</literal> and <literal>MonadResource</literal>, and so can automatically take advantage of
those functionalities.</simpara>
<simpara>In addition to that standard functionality, the following are some common
categories of functions. The only requirement Yesod places on your handler
functions is that, ultimately, they return a type which is an instance of
<literal>ToTypedContent</literal>.</simpara>
<simpara>This section is just a short overview of functionality. For more information,
you should either look through the Haddocks, or read the rest of this book.</simpara>
<section id="yesod-for-haskellers_getting_request_parameters">
<title>Getting request parameters</title>
<simpara>There are a few pieces of information provided by the client in a request:</simpara>
<itemizedlist>
<listitem>
<simpara>
The requested path. This is usually handled by Yesod&#8217;s routing framework, and is not directly queried in a handler function.
</simpara>
</listitem>
<listitem>
<simpara>
Query string parameters. This can be queried using <literal>lookupGetParam</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Request bodies. In the case of URL encoded and multipart bodies, you can use <literal>lookupPostParam</literal> to get the request parameter. For multipart bodies, there&#8217;s also <literal>lookupFile</literal> for file parameters.
</simpara>
</listitem>
<listitem>
<simpara>
Request headers can be queried via <literal>lookupHeader</literal>. (And response headers can be set with <literal>addHeader</literal>.)
</simpara>
</listitem>
<listitem>
<simpara>
Yesod parses cookies for you automatically, and they can be queried using <literal>lookupCookie</literal>. (Cookies can be <emphasis role="strong">set</emphasis> via the <literal>setCookie</literal> function.)
</simpara>
</listitem>
<listitem>
<simpara>
Finally, Yesod provides a user session framework, where data can be set in a cryptographically secure session and associated with each user. This can be queried and set using the functions <literal>lookupSession</literal>, <literal>setSession</literal> and <literal>deleteSession</literal>.
</simpara>
</listitem>
</itemizedlist>
<simpara>While you can use these functions directly for such purposes as processing
forms, you usually will want to use the yesod-form library, which provides a
higher level form abstraction based on applicative functors.</simpara>
</section>
<section id="yesod-for-haskellers_short_circuiting">
<title>Short circuiting</title>
<simpara>In some cases, you&#8217;ll want to short circuit the handling of a request. Reasons
for doing this would be:</simpara>
<itemizedlist>
<listitem>
<simpara>
Send an HTTP redirect, via the <literal>redirect</literal> function. This will default to using the 303 status code. You can use <literal>redirectWith</literal> to get more control over this.
</simpara>
</listitem>
<listitem>
<simpara>
Return a 404 not found with <literal>notFound</literal>, or a 405 bad method via <literal>badMethod</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Indicate some error in the request via <literal>notAuthenticated</literal>, <literal>permissionDenied</literal>, or <literal>invalidArgs</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Send a special response, such as with <literal>sendFile</literal> or <literal>sendResponseStatus</literal> (to override the status 200 response code)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>sendWaiResponse</literal> to drop down a level of abstraction, bypass some Yesod abstractions, and use WAI itself.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="yesod-for-haskellers_streaming">
<title>Streaming</title>
<simpara>So far, the examples of <literal>ToTypedContent</literal> instances I gave all involved
non-streaming responses. <literal>Html</literal>, <literal>Text</literal>, and <literal>Value</literal> all get converted into a
<literal>ContentBuilder</literal> constructor. As such, they cannot interleave I/O with sending
data to the user. What happens if we want to perform such interleaving?</simpara>
<simpara>When we encountered this issue in WAI, we introduced the <literal>responseSource</literal>
method of constructing a response. Using <literal>sendWaiResponse</literal>, we could reuse that
same method for creating a streaming response in Yesod. But there&#8217;s also a
simpler API for doing this: <literal>respondSource</literal>. <literal>respondSource</literal> takes two
parameters: the content type of the response, and a <literal>Source</literal> of <literal>Flush
Builder</literal>. Yesod also provides a number of convenience functions for creating
that <literal>Source</literal>, such as <literal>sendChunk</literal>, <literal>sendChunkBS</literal>, and <literal>sendChunkText</literal>.</simpara>
<simpara>Here&#8217;s an example, which just converts our initial <literal>responseSource</literal> example
from WAI to Yesod.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Blaze.ByteString.Builder           (fromByteString)
import           Blaze.ByteString.Builder.Char.Utf8 (fromShow)
import           Control.Concurrent                 (threadDelay)
import           Control.Monad                      (forM_)
import           Data.Monoid                        ((&lt;&gt;))
import           Network.Wai                        (pathInfo)
import           Yesod.Core                         (HandlerT, RenderRoute (..),
                                                     TypedContent, Yesod,
                                                     YesodDispatch (..), liftIO,
                                                     notFound, respondSource,
                                                     sendChunk, sendChunkBS,
                                                     sendChunkText, sendFlush,
                                                     warp, yesodRunner)

-- | Our foundation datatype.
data App = App

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

getHomeR :: HandlerT App IO TypedContent
getHomeR = respondSource "text/plain" $ do
    sendChunkBS "Starting streaming response.\n"
    sendChunkText "Performing some I/O.\n"
    sendFlush
    -- pretend we're performing some I/O
    liftIO $ threadDelay 1000000
    sendChunkBS "I/O performed, here are some results.\n"
    forM_ [1..50 :: Int] $ \i -&gt; do
        sendChunk $ fromByteString "Got the value: " &lt;&gt;
                    fromShow i &lt;&gt;
                    fromByteString "\n"

instance YesodDispatch App where
    yesodDispatch yesodRunnerEnv req sendResponse =
        let maybeRoute =
                case pathInfo req of
                    [] -&gt; Just HomeR
                    _  -&gt; Nothing
            handler =
                case maybeRoute of
                    Nothing -&gt; notFound
                    Just HomeR -&gt; getHomeR
         in yesodRunner handler yesodRunnerEnv maybeRoute req sendResponse

main :: IO ()
main = warp 3000 App</programlisting>
</section>
</section>
<section id="yesod-for-haskellers_dynamic_parameters">
<title>Dynamic parameters</title>
<simpara>Now that we&#8217;ve finished our detour into the details of the <literal>HandlerT</literal>
transformer, let&#8217;s get back to higher-level Yesod request processing. So far,
all of our examples have dealt with a single supported request route. Let&#8217;s
make this more interesting. We now want to have an application which serves
Fibonacci numbers. If you make a request to <literal>/fib/5</literal>, it will return the fifth
Fibonacci number. And if you visit <literal>/</literal>, it will automatically redirect you to
<literal>/fib/1</literal>.</simpara>
<simpara>In the Yesod world, the first question to ask is: how do we model our route
data type? This is pretty straight-forward: <literal>data Route App = HomeR | FibR
Int</literal>. The question is: how do we want to define our <literal>RenderRoute</literal> instance? We
need to convert the <literal>Int</literal> to a <literal>Text</literal>. What function should we use?</simpara>
<simpara>Before you answer that, realize that we&#8217;ll <emphasis role="strong">also</emphasis> need to be able to parse back a <literal>Text</literal> into an <literal>Int</literal> for dispatch purposes. So we need to make sure that we have a pair of functions with the property <literal>fromText . toText == Just</literal>. <literal>Show</literal>/<literal>Read</literal> could be a candidate for this, except that:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
We&#8217;d be required to convert through <literal>String</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
The <literal>Show</literal>/<literal>Read</literal> instances for <literal>Text</literal> and <literal>String</literal> both involve extra escaping, which we don&#8217;t want to incur.
</simpara>
</listitem>
</orderedlist>
<simpara>Instead, the approach taken by Yesod is the path-pieces package, and in
particular the <literal>PathPiece</literal> typeclass, defined as:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">class PathPiece s where
    fromPathPiece :: Text -&gt; Maybe s
    toPathPiece   :: s    -&gt; Text</programlisting>
<simpara>Using this typeclass, we can write parse and render functions for our route datatype:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">instance RenderRoute App where
    data Route App = HomeR | FibR Int
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ([], [])
    renderRoute (FibR i) = (["fib", toPathPiece i], [])

parseRoute' [] = Just HomeR
parseRoute' ["fib", i] = FibR &lt;$&gt; fromPathPiece i
parseRoute' _ = Nothing</programlisting>
<simpara>And then we can write our <literal>YesodDispatch</literal> typeclass instance:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">instance YesodDispatch App where
    yesodDispatch yesodRunnerEnv req sendResponse =
        let maybeRoute = parseRoute' (pathInfo req)
            handler =
                case maybeRoute of
                    Nothing -&gt; notFound
                    Just HomeR -&gt; getHomeR
                    Just (FibR i) -&gt; getFibR i
         in yesodRunner handler yesodRunnerEnv maybeRoute req sendResponse

getHomeR = redirect (FibR 1)

fibs :: [Int]
fibs = 0 : scanl (+) 1 fibs

getFibR i = return $ show $ fibs !! i</programlisting>
<simpara>Notice our call to <literal>redirect</literal> in <literal>getHomeR</literal>. We&#8217;re able to use the route
datatype as the parameter to <literal>redirect</literal>, and Yesod takes advantage of our
<literal>renderRoute</literal> function to create a textual link.</simpara>
</section>
<section id="yesod-for-haskellers_routing_with_template_haskell">
<title>Routing with Template Haskell</title>
<simpara>Now let&#8217;s suppose we want to add a new route to our previous application. We&#8217;d
have to make the following changes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Modify the <literal>Route</literal> datatype itself.
</simpara>
</listitem>
<listitem>
<simpara>
Add a clause to <literal>renderRoute</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Add a clause to <literal>parseRoute'</literal>, and make sure it corresponds correctly to <literal>renderRoute</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Add a clause to the case statement in <literal>yesodDispatch</literal> to call our handler function.
</simpara>
</listitem>
<listitem>
<simpara>
Write our handler function.
</simpara>
</listitem>
</orderedlist>
<simpara>That&#8217;s a lot of changes! And lots of manual, boilerplate changes means lots of
potential for mistakes. Some of the mistakes can be caught by the compiler if
you turn on warnings (forgetting to add a clause in <literal>renderRoute</literal> or a match in
<literal>yesodDispatch</literal>'s case statement), but others cannot (ensuring that
<literal>renderRoute</literal> and <literal>parseRoute</literal> have the same logic, or adding the <literal>parseRoute</literal>
clause).</simpara>
<simpara>This is where Template Haskell comes into the Yesod world. Instead of dealing
with all of these changes manually, Yesod declares a high level routing syntax.
This syntax lets you specify your route syntax, dynamic parameters, constructor
names, and accepted request methods, and automatically generates parse, render,
and dispatch functions.</simpara>
<simpara>To get an idea of how much manual coding this saves, have a look at our
previous example converted to the Template Haskell version:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE TypeFamilies      #-}
{-# LANGUAGE ViewPatterns      #-}
import           Yesod.Core (RenderRoute (..), Yesod, mkYesod, parseRoutes,
                             redirect, warp)

-- | Our foundation datatype.
data App = App

mkYesod "App" [parseRoutes|
/         HomeR GET
/fib/#Int FibR  GET
|]

instance Yesod App

getHomeR :: Handler ()
getHomeR = redirect (FibR 1)

fibs :: [Int]
fibs = 0 : scanl (+) 1 fibs

getFibR :: Int -&gt; Handler String
getFibR i = return $ show $ fibs !! i

main :: IO ()
main = warp 3000 App</programlisting>
<simpara>What&#8217;s wonderful about this is, as the developer, you can now focus on the
important part of your application, and not get involved in the details of
writing parsers and renderers. There are of course some downsides to the usage
of Template Haskell:</simpara>
<itemizedlist>
<listitem>
<simpara>
Compile times are a bit slower.
</simpara>
</listitem>
<listitem>
<simpara>
The details of what&#8217;s going on behind the scenes aren&#8217;t easily apparent. (Though you can use <literal>cabal haddock</literal> to see what identifiers have been generated for you.)
</simpara>
</listitem>
<listitem>
<simpara>
You don&#8217;t have as much fine-grained control. For example, in the Yesod route syntax, each dynamic parameter has to be a separate field in the route constructor, as opposed to bundling fields together. This is a conscious trade-off in Yesod between flexibility and complexity.
</simpara>
</listitem>
</itemizedlist>
<simpara>This usage of Template Haskell is likely the most controversial decision in
Yesod. I personally think the benefits definitely justify its usage. But if
you&#8217;d rather avoid Template Haskell, you&#8217;re free to do so. Every example so far
in this chapter has done so, and you can follow those techniques. We also have
another, simpler approach in the Yesod world: <literal>LiteApp</literal>.</simpara>
<section id="yesod-for-haskellers_liteapp">
<title>LiteApp</title>
<simpara><literal>LiteApp</literal> allows you to throw away type safe URLs and Template Haskell. It uses
a simple routing DSL in pure Haskell. Once again, as a simple comparison, let&#8217;s
rewrite our Fibonacci example to use it.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">import           Data.Text  (pack)
import           Yesod.Core (LiteHandler, dispatchTo, dispatchTo, liteApp,
                             onStatic, redirect, warp, withDynamic)

getHomeR :: LiteHandler ()
getHomeR = redirect "/fib/1"

fibs :: [Int]
fibs = 0 : scanl (+) 1 fibs

getFibR :: Int -&gt; LiteHandler String
getFibR i = return $ show $ fibs !! i

main :: IO ()
main = warp 3000 $ liteApp $ do
    dispatchTo getHomeR
    onStatic (pack "fib") $ withDynamic $ \i -&gt; dispatchTo (getFibR i)</programlisting>
<simpara>There you go, a simple Yesod app without any language extensions at all!
However, even this application still demonstrates some type safety. Yesod will
use <literal>fromPathPiece</literal> to convert the parameter for <literal>getFibR</literal> from <literal>Text</literal> to an
<literal>Int</literal>, so any invalid parameter will be got by Yesod itself. It&#8217;s just one less
piece of checking that you have to perform.</simpara>
</section>
</section>
<section id="yesod-for-haskellers_shakespeare">
<title>Shakespeare</title>
<simpara>While generating plain text pages can be fun, it&#8217;s hardly what one normally
expects from a web framework. As you&#8217;d hope, Yesod comes built in with support
for generating HTML, CSS and Javascript as well.</simpara>
<simpara>Before we get into templating languages, let&#8217;s do it the raw, low-level way,
and then build up to something a bit more pleasant.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">import           Data.Text  (pack)
import           Yesod.Core

getHomeR :: LiteHandler TypedContent
getHomeR = return $ TypedContent typeHtml $ toContent
    "&lt;html&gt;&lt;head&gt;&lt;title&gt;Hi There!&lt;/title&gt;\
    \&lt;link rel='stylesheet' href='/style.css'&gt;\
    \&lt;script src='/script.js'&gt;&lt;/script&gt;&lt;/head&gt;\
    \&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"

getStyleR :: LiteHandler TypedContent
getStyleR = return $ TypedContent typeCss $ toContent
    "h1 { color: red }"

getScriptR :: LiteHandler TypedContent
getScriptR = return $ TypedContent typeJavascript $ toContent
    "alert('Yay, Javascript works too!');"

main :: IO ()
main = warp 3000 $ liteApp $ do
    dispatchTo getHomeR
    onStatic (pack "style.css") $ dispatchTo getStyleR
    onStatic (pack "script.js") $ dispatchTo getScriptR</programlisting>
<simpara>We&#8217;re just reusing all of the <literal>TypedContent</literal> stuff we&#8217;ve already learnt. We now
have three separate routes, providing HTML, CSS and Javascript. We write our
content as <literal>String</literal>s, convert them to <literal>Content</literal> using <literal>toContent</literal>, then wrap
them with a <literal>TypedContent</literal> constructor to give them the appropriate
content-type headers.</simpara>
<simpara>But as usual, we can do better. Dealing with <literal>String</literal>s is not very efficient,
and it&#8217;s tedious to have to manually put in the content type all the time. But
we already know the solution to those problems: use the <literal>Html</literal> datatype from
<literal>blaze-html</literal>. Let&#8217;s convert our <literal>getHomeR</literal> function to use it:</simpara>
<programlisting language="haskell" linenumbering="unnumbered">import           Data.Text                   (pack)
import           Text.Blaze.Html5            (toValue, (!))
import qualified Text.Blaze.Html5            as H
import qualified Text.Blaze.Html5.Attributes as A
import           Yesod.Core

getHomeR :: LiteHandler Html
getHomeR = return $ H.docTypeHtml $ do
    H.head $ do
        H.title $ toHtml "Hi There!"
        H.link ! A.rel (toValue "stylesheet") ! A.href (toValue "/style.css")
        H.script ! A.src (toValue "/script.js") $ return ()
    H.body $ do
        H.h1 $ toHtml "Hello World!"

getStyleR :: LiteHandler TypedContent
getStyleR = return $ TypedContent typeCss $ toContent
    "h1 { color: red }"

getScriptR :: LiteHandler TypedContent
getScriptR = return $ TypedContent typeJavascript $ toContent
    "alert('Yay, Javascript works too!');"

main :: IO ()
main = warp 3000 $ liteApp $ do
    dispatchTo getHomeR
    onStatic (pack "style.css") $ dispatchTo getStyleR
    onStatic (pack "script.js") $ dispatchTo getScriptR</programlisting>
<simpara>Ahh, far nicer. <literal>blaze-html</literal> provides a convenient combinator library, and will
execute far faster in most cases than whatever <literal>String</literal> concatenation you might
attempt.</simpara>
<simpara>If you&#8217;re happy with <literal>blaze-html</literal> combinators, by all means use them. However,
many people like to use a more specialized templating language. Yesod&#8217;s
standard provider for this is the Shakespearean languages: Hamlet, Lucius, and
Julius. You are by all means welcome to use a different system if so desired,
the only requirement is that you can get a <literal>Content</literal> value from the template.</simpara>
<simpara>Since Shakespearean templates are compile-time checked, their usage requires
either quasiquotation or Template Haskell. We&#8217;ll go for the former approach
here. Please see the Shakespeare chapter in the book for more information.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE QuasiQuotes #-}
import           Data.Text   (Text, pack)
import           Text.Julius (Javascript)
import           Text.Lucius (Css)
import           Yesod.Core

getHomeR :: LiteHandler Html
getHomeR = withUrlRenderer $
    [hamlet|
        $doctype 5
        &lt;html&gt;
            &lt;head&gt;
                &lt;title&gt;Hi There!
                &lt;link rel=stylesheet href=/style.css&gt;
                &lt;script src=/script.js&gt;
            &lt;body&gt;
                &lt;h1&gt;Hello World!
    |]

getStyleR :: LiteHandler Css
getStyleR = withUrlRenderer [lucius|h1 { color: red }|]

getScriptR :: LiteHandler Javascript
getScriptR = withUrlRenderer [julius|alert('Yay, Javascript works too!');|]

main :: IO ()
main = warp 3000 $ liteApp $ do
    dispatchTo getHomeR
    onStatic (pack "style.css") $ dispatchTo getStyleR
    onStatic (pack "script.js") $ dispatchTo getScriptR</programlisting>
<section id="yesod-for-haskellers_url_rendering_function">
<title>URL rendering function</title>
<simpara>Likely the most confusing part of this is the <literal>withUrlRenderer</literal> calls. This
gets into one of the most powerful features of Yesod: type-safe URLs. If you
notice in our HTML, we&#8217;re providing links to the CSS and Javascript URLs via
strings. This leads to a duplication of that information, as in our <literal>main</literal>
function we have to provide those strings a second time. This is very fragile:
our codebase is one refactor away from having broken links.</simpara>
<simpara>The recommended approach instead would be to use our type-safe URL datatype in
our template instead of including explicit strings. As mentioned above,
<literal>LiteApp</literal> doesn&#8217;t provide any meaningful type-safe URLs, so we don&#8217;t have that
option here. But if you use the Template Haskell generators, you get type-safe
URLs for free.</simpara>
<simpara>In any event, the Shakespearean templates all expect to receive a function to
handle the rendering of a type-safe URL. Since we don&#8217;t actually use any
type-safe URLs, just about any function would work here (the function will be
ignored entirely), but <literal>withUrlRenderer</literal> is a convenient way of doing this.</simpara>
<simpara>As we&#8217;ll see next, <literal>withUrlRenderer</literal> isn&#8217;t really needed most of the time,
since Widgets end up providing the renderer function for us automatically.</simpara>
</section>
</section>
<section id="yesod-for-haskellers_widgets">
<title>Widgets</title>
<simpara>Dealing with HTML, CSS and Javascript as individual components can be nice in
many cases. However, when you want to build up reusable components for a page,
it can get in the way of composability. If you want more motivation for why
widgets are useful, please see the widget chapter. For now, let&#8217;s just dig into
using them.</simpara>
<programlisting language="haskell" linenumbering="unnumbered">{-# LANGUAGE QuasiQuotes #-}
import           Yesod.Core

getHomeR :: LiteHandler Html
getHomeR = defaultLayout $ do
    setTitle $ toHtml "Hi There!"
    [whamlet|&lt;h1&gt;Hello World!|]
    toWidget [lucius|h1 { color: red }|]
    toWidget [julius|alert('Yay, Javascript works too!');|]

main :: IO ()
main = warp 3000 $ liteApp $ dispatchTo getHomeR</programlisting>
<simpara>This is the same example as above, but we&#8217;ve now condensed it into a single
handler. Yesod will automatically handle providing the CSS and Javascript to
the HTML. By default, it will place them in <literal>style</literal> and <literal>script</literal> tags in the
<literal>head</literal> and <literal>body</literal> of the page, respectively, but Yesod provides many
customization settings to do other things (such as automatically creating
temporary static files and linking to them).</simpara>
<simpara>Widgets also have another advantage. The <literal>defaultLayout</literal> function is a member
of the <literal>Yesod</literal> typeclass, and can be modified to provide a customized
look-and-feel for your website. Many built-in pieces of Yesod, such as error
messages, take advantage of the widget system, so by using widgets, you get a
consistent feel throughout your site.</simpara>
</section>
<section id="yesod-for-haskellers_details_we_won_8217_t_cover">
<title>Details we won&#8217;t cover</title>
<simpara>Hopefully this chapter has pulled back enough of the &#8220;magic&#8221; in Yesod to let
you understand what&#8217;s going on under the surface. We could of course continue
using this approach for analyze the rest of the Yesod ecosystem, but that would
be mostly redundant with the rest of this book. Hopefully you can now feel more
informed as you read chapters on Persistent, forms, sessions, and subsites.</simpara>
</section>
</section>
</article>
